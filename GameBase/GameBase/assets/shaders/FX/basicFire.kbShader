//===================================================================================================
// basicFire.kbShader
//
//
// 2018 kbEngine 2.0
//===================================================================================================
cbuffer matrixBuffer {
	matrix mvpMatrix;
	float4 cameraPos;
	float4 noiseScroll;
	float4 noiseScale;
	float4 time;
	float4 startFireColor;
	float4 endFireColor;
	float4 distortion_1_2;
	float4 distortion_3;
	float4 fireDistortion;
};

kbShaderState {
	srcblend Blend_SrcAlpha
	dstBlend Blend_InvSrcAlpha
	blendOp BlendOp_Add

	srcBlendAlpha Blend_One
	dstBlendAlpha Blend_Zero
	colorWriteEnable ColorWriteEnable_rgba

	cullmode cullmode_none
}

//-------------------------------------
struct vertexInput {
	float4 position			: POSITION;
	float2 uv				: TEXCOORD0;
	float4 color			: COLOR;
	float4 normal			: NORMAL;
	float4 tangent			: TANGENT;
};

//-------------------------------------
struct pixelInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float4 color			: COLOR;
	float2 position2		: TEXCOORD1;
};

//-------------------------------------
struct PS_OUTPUT {
	float4 Color			: SV_TARGET0;
	float4 Normal			: SV_TARGET1;
	float4 Specular			: SV_TARGET2;
	float2 Depth			: SV_TARGET3;
};


/**
 *	vertexShader
 */
pixelInput vertexShader( vertexInput input ) {
	pixelInput output = (pixelInput)(0);

	output.position = mul( input.position, mvpMatrix );
	output.uv = input.uv;
	output.color = input.color;
	output.position2 = output.position.zw;

	return output;
}

/**
 *	pixelShader
 */
Texture2D fireNoiseMap				: register(t0);
SamplerState SampleType;

Texture2D noiseMap1					: register(t1);
Texture2D noiseMap2					: register(t2);
Texture2D noiseMap3					: register(t3);
 
float4 pixelShader( pixelInput	input ) : SV_Target {

	float4 noise1 = noiseMap1.Sample( SampleType, input.uv + float2( 0.0f, noiseScroll.x * time.x ) ) * 2.0f - 1.0f;
	float4 noise2 = noiseMap2.Sample( SampleType, input.uv + float2( 0.0f, noiseScroll.y * time.x ) ) * 2.0f - 1.0f;
	float4 noise3 = noiseMap3.Sample( SampleType, input.uv + float2( 0.0f, noiseScroll.z * time.x ) ) * 2.0f - 1.0f;
	noise1.xy *= distortion_1_2.xy;
	noise2.xy *= distortion_1_2.zw;
	noise3.xy *= distortion_3.xy;

	float2 finalNoise = ( noise1 + noise2 + noise3 ).xy;
	float perturb = ( ( 1.0f - input.uv.y) * fireDistortion.x ) + fireDistortion.y;

	float4 fireNoise = fireNoiseMap.Sample( SampleType, saturate( input.uv * 0.2f + finalNoise * perturb ) );
	fireNoise.w = fireNoiseMap.Sample( SampleType, saturate( input.uv + finalNoise * perturb ) ).w;

	float lerpVal = saturate(fireNoise.y + fireNoise.z + perturb) - fireNoise.w * 0.05f;
//	lerpVal += abs(input.uv.y - 1.0f) * 0.5f;
	//lerpVal += abs(input.uv.x - 0.5f) * 1.5f;

		lerpVal = saturate(lerpVal);
	float4 color;
	color.xyz = saturate(lerp(startFireColor.w * startFireColor.xyz, endFireColor.w * endFireColor.xyz, lerpVal ));
	color.w = fireNoise.w * 1;

	 float dist = 0.5f;
	dist = 1.0f - saturate((dist - input.uv.y )/ dist);
	color.w *= dist;//* (lerpVal * 1.75f);
	//	color.w = 0.0f;
	return color;
}
