//==============================================================================
// basicTerrain.kbShader
//
// 2018 kbEngine 2.0
//==============================================================================
cbuffer matrixBuffer {
	matrix modelMatrix;
	matrix mvpMatrix;
	matrix vpMatrix;
	float4 mat1And2UVScale;
	float4 mat3And4UVScale;
};

//-------------------------------------
struct vertexInput {
	float4 position			: POSITION;
	float2 uv				: TEXCOORD0;
	float4 binormal			: COLOR;
	float4 normal			: NORMAL;
	float4 tangent			: TANGENT;
};

//-------------------------------------
struct pixelInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float4 color			: COLOR;
	float2 position2		: TEXCOORD1;
	float3 tangent			: TEXCOORD2;
	float3 binormal			: TEXCOORD3;
	float3 normal			: TEXCOORD4;
};

//-------------------------------------
struct PS_OUTPUT {
	float4 Color			: SV_TARGET0;
	float4 Normal			: SV_TARGET1;
	float4 Spec				: SV_TARGET2;
	float2 Depth			: SV_TARGET3;
};


/**
 *	vertexShader
 */
pixelInput vertexShader( vertexInput input ) {
	pixelInput output = (pixelInput)(0);

	output.position = input.position;//mul( input.position, mvpMatrix );
	output.uv = input.uv;
	output.position2 = output.position.zw;


	output.tangent = ( input.tangent.xyz * 2.0f ) - 1.0f;
	output.binormal = ( input.binormal.xyz * 2.0f ) - 1.0f;
	output.normal = ( input.normal.xyz * 2.0f ) - 1.0f;

	return output;

}

/**
 *	geomteryShader
 */
SamplerState SampleType;
Texture2D grassMap : register(t0);

 [maxvertexcount(4)]
 void geometryShader( point pixelInput input[1], inout TriangleStream<pixelInput> OutputStream ) {


	pixelInput newPoint1 = input[0];
	newPoint1.position = mul( newPoint1.position + float4(100,0,0,0), vpMatrix ) * grassMap.SampleLevel( SampleType, input[0].uv, 0.0f ).r;
	newPoint1.position2 = newPoint1.position.zw;

	pixelInput newPoint2 = input[0];
	newPoint2.position =  mul( newPoint2.position + float4(0, -100,0,0), vpMatrix ) * grassMap.SampleLevel( SampleType, input[0].uv, 0.0f ).r;
	newPoint2.position2 = newPoint2. position.zw;

	OutputStream.Append( newPoint1 );
	OutputStream.Append( newPoint2 );


	pixelInput newPoint3 = input[0];
	newPoint3.position = mul( newPoint3.position, vpMatrix ) * grassMap.SampleLevel( SampleType, input[0].uv, 0.0f ).r;
	newPoint3.position2 = newPoint3.position.zw;
	
	OutputStream.Append( newPoint3 );
 }

/**
 *	pixelShader
 */ 


Texture2D Mat4Diffuse	: register(t7);

 PS_OUTPUT pixelShader( pixelInput	input )  {
 	PS_OUTPUT output = (PS_OUTPUT) 0;

	output.Color.xyz = 1;
	output.Normal.xyz = 1;

	//dsfdsf
	output.Spec = float4( 1.0f, 0.0f, 0.0f, 1.0f );
	output.Depth.r = input.position2.x / input.position2.y;

	return output;
}
