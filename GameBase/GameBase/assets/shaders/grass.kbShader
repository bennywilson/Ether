//==============================================================================
// grass.kbShader
//
// 2018 kbEngine 2.0
//==============================================================================
cbuffer ConstantBuffer1 {
	matrix modelMatrix;
	matrix vpMatrix;
	float4 bladeParameters;
	float4 GrassData1;
	float4 GrassData2;
	float4 cameraPos;
	float4 jitterOffsets[64];
	float4 wind;
	float4 time;
	float4 fakeAOData;		// x - Darkness, y - power
	float4 collisionMapCenter;
	float4 collisionMapPixelWorldSize;
	//float4 collisionSphere;
};


kbShaderState {
	cullMode CullMode_None
}

//-------------------------------------
struct vertexInput {
	float4 position			: POSITION;
	float2 uv				: TEXCOORD0;
	float4 blendIndices		: BLENDINDICES;
};

struct geometryShaderInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float4 blendIndices		: BLENDINDICES;
};

//-------------------------------------
struct pixelInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float2 position2		: TEXCOORD1;
	float4 grassData1		: TEXCOORD2;		// x = inverse alpha mask, y = burn start height, z = burn time, w = starting U
	float4 worldPosition	: TEXCOORD3;		// z = 
};

//-------------------------------------
struct PS_OUTPUT {
	float4 Color			: SV_TARGET0;
	float4 Normal			: SV_TARGET1;
	float4 Spec				: SV_TARGET2;
	float2 Depth			: SV_TARGET3;
};

/**
 *	vertexShader
 */
geometryShaderInput vertexShader( vertexInput input ) {
	geometryShaderInput output = (geometryShaderInput)(0);

	output.position = mul( input.position, modelMatrix );
	output.uv = input.uv;
	output.blendIndices = input.blendIndices;
	return output;
}

/**
 *	geometryShader
 */
SamplerState SampleType;
SamplerState PointSampler;

Texture2D grassMap			: register(t0);
Texture2D heightMap			: register(t1);
Texture2D grassDiffuseMap	: register(t2);
Texture2D noiseMap			: register(t3);
Texture2D collisionMap		: register(t4);

void CreateVertex( inout TriangleStream<pixelInput> OutputStream, float3 vertexWorldOrigin, float2 uv, float4 grassData, float u, float rand ) {

	pixelInput newVertex;
	newVertex.position	= mul( float4( vertexWorldOrigin, 1.0f ), vpMatrix );
	newVertex.position2 = newVertex.position.zw;
	newVertex.grassData1.rgb = grassData.rgb;
	newVertex.grassData1.w = u;
	newVertex.uv = uv;
	newVertex.worldPosition.xyz = vertexWorldOrigin;
	newVertex.worldPosition.w = rand;
	OutputStream.Append( newVertex );
};

 void CreateGrassBlade( const float3 bladeLocalOrigin, point geometryShaderInput input[1], inout TriangleStream<pixelInput> OutputStream, float lodScale, int grassNumber ) {

	const int4 IndexVector = D3DCOLORtoUBYTE4( input[0].blendIndices );
	const float startHeight = heightMap.SampleLevel( SampleType, input[0].uv, 0.0f ).r * GrassData1.x;
	const float3 bladeWorldOrigin = float3( 0.0f, startHeight, 0.0f ) + bladeLocalOrigin + float3( jitterOffsets[IndexVector.x + grassNumber].z, 0.0f, jitterOffsets[IndexVector.x + grassNumber].w ) + wind.xyz + input[0].position.xyz;

	float2 terrainMapUV;
	terrainMapUV.x = ( ( bladeWorldOrigin.x - collisionMapCenter.x ) / collisionMapCenter.z ) * 0.5f + 0.5f;
	terrainMapUV.y = ( ( bladeWorldOrigin.z - collisionMapCenter.y ) / collisionMapCenter.z ) * 0.5f + 0.5f;

	float4 collisionMapVal = collisionMap.SampleLevel( PointSampler, terrainMapUV, 0.0f );
	const float3 noiseValues = noiseMap.SampleLevel( SampleType, input[0].uv * grassNumber, 0.0f ).xyz;

	// Check collision
	float3 windpush = 0.0f;
	if ( length( collisionMapVal.xy ) > 0.000f ) {
		float2 centerPt = terrainMapUV;
		centerPt = ( centerPt * 2.0f ) - 1.0f;
		centerPt += collisionMapVal.xy;
		centerPt *= collisionMapCenter.z;
		float3 worldCenterPt = float3( centerPt.x, collisionMapVal.w, centerPt.y );

		float3 vecTo = bladeWorldOrigin - worldCenterPt.xyz;
		float collisionRadius = 32.0f;

		windpush = 1.0f - saturate( length( vecTo ) / collisionRadius);
		
		windpush *= normalize( vecTo ) * collisionRadius * 0.33f * ( 1.0f + noiseValues.x * 0.25f );
	}

/*	if ( length( collisionSphere.xz - bladeWorldOrigin.xz ) < collisionSphere.w && abs( collisionSphere.y - bladeWorldOrigin.y ) < collisionSphere.w ) {
		float3 vecTo = bladeWorldOrigin - collisionSphere.xyz;
		vecTo.y = min( vecTo.y, 0.0f );
		windpush = 1.0f - saturate( length( vecTo ) / collisionSphere.w );
		windpush *= normalize( vecTo ) * collisionSphere.w * 2.f;
	}*/

	const float oscNoise = noiseValues.x * 5.0f;
	float oscillation = sin( oscNoise.x + time.x * ( 1.0f * ( ( oscNoise.x * 0.5f ) + 0.5f ) ) ) * 0.5f + 0.5f;
	const float3 windVec = ( windpush + ( wind.xyz ) * ( oscillation * 0.1f ) + 0.9f );

	const float3 jitterOffset = float3( jitterOffsets[IndexVector.x + grassNumber].x, 0.0f, jitterOffsets[IndexVector.x + grassNumber].y );

	float randIt = frac( 3.5349578345f * ( bladeWorldOrigin.x + bladeWorldOrigin.z ) );
	int textureIdx = 0;
	if ( randIt > 0.96f )
		textureIdx = 1;
	else if ( randIt > 0.9f )
		textureIdx = 2;

	const float textureBorderSize = 0.0f;
	const float textureSize = ( 1.0f / 8.0f ) - textureBorderSize;	// Assumes 8 plant textures packed together.  Polygonal grass is at index 0
	const float textureStartU = textureSize * textureIdx;
	const float textureEndU = textureStartU + textureSize;

	const float grassLength = ( ( bladeParameters.w - bladeParameters.z ) * noiseValues.x + bladeParameters.z ) * lodScale;
	const float3 segmentVec = normalize( float3( 0.0f, grassLength, 0.0f ) + windVec ) * ( grassLength * 0.33333f );
	const float3 segmentVec_2X = segmentVec * 2.0f;
	const float3 segmentVec_3X = segmentVec * 3.0f;

	float burnStartHeight = collisionMapVal.w + 99999.0f;
	int numSegments = 3;
	if ( bladeWorldOrigin.y + ( grassLength *  0.33333f ) > collisionMapVal.w ) {
		burnStartHeight = bladeWorldOrigin.y + ( grassLength * 0.33333f ) - 0.0001f;
		numSegments = 1;
	} else if ( bladeWorldOrigin.y + ( grassLength *  0.67f ) > collisionMapVal.w ) {
		burnStartHeight = bladeWorldOrigin.y + ( grassLength *  0.67f )- 0.0001f;
		numSegments = 2;
	}
	float4 grassData = 0;
	grassData.x = ( textureIdx == 0 ) ? ( 1 ) : ( 0 );	// Polygonal grass (index 0) doesn't require any clipping
	grassData.y = burnStartHeight;
	grassData.z = collisionMapVal.b;

	CreateVertex( OutputStream, bladeWorldOrigin, float2( textureStartU, 1.0f - textureBorderSize ), grassData, 0, randIt );
	CreateVertex( OutputStream, bladeWorldOrigin + jitterOffset, float2( textureEndU, 1.0f - textureBorderSize ), grassData, 1, randIt );

	CreateVertex( OutputStream, bladeWorldOrigin + segmentVec, float2( textureStartU, 0.67f ), grassData, 0, randIt );
	CreateVertex( OutputStream, bladeWorldOrigin + jitterOffset + segmentVec, float2( textureEndU, 0.67f ), grassData, 1, randIt );

	if ( numSegments > 1 ) {
		CreateVertex( OutputStream, bladeWorldOrigin + segmentVec_2X, float2( textureStartU, 0.33f ), grassData, 0, randIt );
		CreateVertex( OutputStream, bladeWorldOrigin + jitterOffset + segmentVec_2X, float2( textureEndU, 0.33f ), grassData, 1, randIt );

		if ( numSegments > 2 ) {
			if ( textureIdx == 0 ) {
				CreateVertex( OutputStream, bladeWorldOrigin + jitterOffset * 0.5f + segmentVec_3X, float2( ( textureStartU + textureEndU ) * 0.5f, textureBorderSize ), grassData, 0.5f, randIt );
			} else {
				CreateVertex( OutputStream, bladeWorldOrigin + segmentVec_3X, float2( textureStartU, textureBorderSize ), grassData, 0, randIt );
				CreateVertex( OutputStream, bladeWorldOrigin + jitterOffset + segmentVec_3X, float2( ( textureStartU + textureEndU ) * 0.5f, textureBorderSize ), grassData, 1.0f, randIt );
			}
		}
	}

	OutputStream.RestartStrip();
 }

 [maxvertexcount(32)]
 void geometryShader( point geometryShaderInput input[1], inout TriangleStream<pixelInput> OutputStream ) {

	float scale = 1.0f - saturate( ( length( cameraPos.xyz - input[0].position.xyz ) - GrassData2.x ) * GrassData2.y );
	if ( scale == 0.0f ) {
		return;
	}

	const int numSides = 2;
	float dist = GrassData1.z / 2.0f;
	int grassIdx = 0;

	for ( int y = 0; y < 2; y++ ) {
		for ( int x = 0; x < 2; x++, grassIdx++ ) {

			CreateGrassBlade( float3( x * dist, 0, y * dist ), input, OutputStream, scale, grassIdx );
		}
	}
 }

/**
 *	pixelShader
 */ 


Texture2D emberGradientTex	: register(t5);

PS_OUTPUT pixelShader( pixelInput input, bool isFrontFace : SV_IsFrontFace )  {
 	PS_OUTPUT output = (PS_OUTPUT) 0;

	float fakeAO = abs( ( 1.0f - input.uv.y ) * ( 1.0f - fakeAOData.x ) + fakeAOData.x );
	fakeAO = pow( fakeAO, abs(fakeAOData.y) );

	if ( input.uv.x >= 2.0f/8.0f ) fakeAO = 1;
	float4 foliageColor = grassDiffuseMap.Sample( SampleType, input.uv );
	output.Color.xyz = foliageColor.xyz * fakeAO;

	const float3 noiseValues = noiseMap.Sample( SampleType, input.uv ).xyz;
	float burnSize = 0.777f + input.worldPosition.w * 2.0f;

	if ( abs( input.worldPosition.y - input.grassData1.y ) <= burnSize ) {

		const float normalizedTime = ( input.worldPosition.w * 0.33f ) + saturate( ( 1.0f + noiseValues.g ) * ( ( time.x - input.grassData1.z ) / 1.0f ) );

		float animatedEmberU = clamp( normalizedTime, 0.0f, 0.99f );
		const float3 ember = emberGradientTex.Sample( SampleType, float2( animatedEmberU, 0.0f ) ).xyz;

		float lerpVal = ( burnSize - abs(input.worldPosition.y - input.grassData1.y ) ) / burnSize;
		lerpVal = saturate( lerpVal );
		output.Color.xyz = lerp( output.Color.xyz, ember, lerpVal);
		output.Color.w = saturate( lerpVal - 0.5f ) * 2.0f;
	}
	clip( ( input.grassData1.r + foliageColor.w ) - 0.01f );

	output.Normal.xyz = float3( 0.0f, 1.0f,0.0 );

	output.Spec = float4(0,0,0,1);//float4( 0.25f, 0.25f, 0.25f, 1.0f );
	output.Depth.r = input.position2.x / input.position2.y;

	return output;
}
