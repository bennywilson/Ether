//==============================================================================
// grass.kbShader
//
// 2018 kbEngine 2.0
//==============================================================================
cbuffer ConstantBuffer1 {
	matrix modelMatrix;
	matrix vpMatrix;
	float4 bladeParameters;
	float4 GrassData1;
	float4 GrassData2;
	float4 cameraPos;
	float4 bladeOffsets[64];
	float4 bladeHeights[32];
	float4 wind;
	float4 time;
	float4 fakeAOData;		// x - Darkness, y - power
	float4 collisionSphere;
};


//-------------------------------------
struct vertexInput {
	float4 position			: POSITION;
	float2 uv				: TEXCOORD0;
	float4 blendIndices		: BLENDINDICES;
};

struct geometryShaderInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float4 blendIndices		: BLENDINDICES;
};

//-------------------------------------
struct pixelInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float2 position2		: TEXCOORD1;
	float clipParam			: TEXCOORD2;
//	float3 normal			: TEXCOORD2;
};

//-------------------------------------
struct PS_OUTPUT {
	float4 Color			: SV_TARGET0;
	float4 Normal			: SV_TARGET1;
	float4 Spec				: SV_TARGET2;
	float2 Depth			: SV_TARGET3;
};

/**
 *	vertexShader
 */
geometryShaderInput vertexShader( vertexInput input ) {
	geometryShaderInput output = (geometryShaderInput)(0);

	output.position = mul( input.position, modelMatrix );
	output.uv = input.uv;
	output.blendIndices = input.blendIndices;
	return output;
}

/**
 *	geometryShader
 */
SamplerState SampleType;
Texture2D grassMap			: register(t0);
Texture2D heightMap			: register(t1);
Texture2D grassDiffuseMap	: register(t2);
Texture2D noiseMap			: register(t3);

void CreateVertex( inout pixelInput output, geometryShaderInput input, float3 bladeLocalStart, float3 curVertexOffset, float2 uv, float clipParam ) {

	float4 localPos = input.position + float4( bladeLocalStart + curVertexOffset, 0.0f );

	output.position	= mul( localPos, vpMatrix);
	output.position2 = output.position.zw;
	output.clipParam = clipParam;
	output.uv = uv;
};

 void CreateGrassBlade( float3 grassOffset, point geometryShaderInput input[1], inout TriangleStream<pixelInput> OutputStream, float lodScale, int grassIdx ) {

	int4 IndexVector = D3DCOLORtoUBYTE4( input[0].blendIndices );
	int   IndexArray[4]        = (int[4])IndexVector;
	
	float3 bladeOff = float3( bladeOffsets[IndexArray[0] + grassIdx].x, 0.0f, bladeOffsets[IndexArray[0] + grassIdx].y );

	float halfWidth = bladeParameters.y;

	const float startHeight = heightMap.SampleLevel( SampleType, input[0].uv, 0.0f ).r * GrassData1.x;
	float3 bladeLocalStartPos = float3( 0.0f, startHeight, 0.0f ) + grassOffset + float3( bladeOffsets[IndexArray[0] + grassIdx].z, 0.0f, bladeOffsets[IndexArray[0] + grassIdx].w ) + wind.xyz;
	

	/*

	*/
	const float3 noiseValues = noiseMap.SampleLevel( SampleType, input[0].uv * grassIdx, 0.0f).xyz;
	float height = ( ( bladeParameters.w - bladeParameters.z ) * noiseValues.x + bladeParameters.z )* lodScale;

	const float stepHeight = height / 3.0f;
	const float3 stepUpVec = float3( 0.0f, stepHeight, 0.0f );
	const float3 stepUpVecX2 = 2 * stepUpVec;
	const float3 steUpVecX3 = 3.0f * stepUpVec;

	const int texIdx = round( input[0].blendIndices.z * 256.0f );
	const float textureBorderSize = 0.0f;
	const float textureSize = 0.125f;//(1.0f / 8.0f) - textureBorderSize;
	const float textureStart = textureSize * texIdx;//+ textureBorderSize;
	const float textureEnd = textureStart + textureSize;
	float clipParam = 0;
	if (texIdx < 1 )
		clipParam = 1;

	const float oscNoise = noiseValues.x * 5.0f;
	float oscillation = sin(oscNoise.x + time.x * (1.0f * ((oscNoise.x * 0.5f) + 0.5f))) * 0.5f + 0.5f;

	float3 windpush = 0.0f;
	const float3 bladeWorldStart = bladeLocalStartPos + input[0].position.xyz;
	if ( length( collisionSphere.xz - bladeWorldStart.xz ) < collisionSphere.w && abs(collisionSphere.y - bladeWorldStart.y) < collisionSphere.w ) {
		float3 vecTo = bladeWorldStart - collisionSphere.xyz;
		vecTo.y = min( vecTo.y, 0.0f );
		windpush = 1.0f - saturate( length( vecTo ) / collisionSphere.w );
		windpush *= normalize( vecTo ) * collisionSphere.w * 0.55f;
	}

	const float3 windAmt = windpush + ( wind.xyz) * ( oscillation * 0.1f) + 0.9f;
	const float3 windAmt2X = windAmt * 2.0f;
	const float3 windAmt3X = windAmt * 3.0f;

	pixelInput newPoint1 = (pixelInput)0;
	CreateVertex( newPoint1, input[0], bladeLocalStartPos, float3( 0.0f, 0.0f, 0.0f ), float2( textureStart, 1.0f - textureBorderSize ), clipParam );
	OutputStream.Append( newPoint1 );

	pixelInput newPoint2 = (pixelInput)0;
	CreateVertex( newPoint2, input[0], bladeLocalStartPos, bladeOff, float2( textureEnd, 1.0f - textureBorderSize ), clipParam );
	OutputStream.Append( newPoint2 );

	pixelInput newPoint3 = (pixelInput)0;
	CreateVertex( newPoint3, input[0], bladeLocalStartPos, stepUpVec + windAmt, float2( textureStart, 0.67f ), clipParam );
	OutputStream.Append( newPoint3 );

	pixelInput newPoint4 = (pixelInput)0;
	CreateVertex( newPoint4, input[0], bladeLocalStartPos, bladeOff + stepUpVec + windAmt, float2( textureEnd, 0.67f ), clipParam );
	OutputStream.Append( newPoint4 );

	pixelInput newPoint5 = (pixelInput)0;
	CreateVertex( newPoint5, input[0], bladeLocalStartPos, stepUpVecX2 + windAmt2X, float2( textureStart, 0.33f ), clipParam );
	OutputStream.Append( newPoint5 );

	pixelInput newPoint6 = (pixelInput)0;
	CreateVertex( newPoint6, input[0], bladeLocalStartPos, bladeOff + stepUpVecX2 + windAmt2X, float2( textureEnd, 0.33f ), clipParam  );
	OutputStream.Append( newPoint6 );

	if ( texIdx < 1 ) {
		pixelInput newPoint7 = (pixelInput)0;
		CreateVertex( newPoint7, input[0], bladeLocalStartPos, steUpVecX3 + bladeOff * 0.5f + windAmt3X, float2( ( textureStart + textureEnd ) * 0.5f, textureBorderSize ), clipParam );
		OutputStream.Append( newPoint7 );
	} else {
		pixelInput newPoint7 = (pixelInput)0;
		CreateVertex( newPoint7, input[0], bladeLocalStartPos, steUpVecX3 + windAmt3X, float2( textureStart, textureBorderSize ), clipParam );
		OutputStream.Append( newPoint7 );	

		pixelInput newPoint8 = (pixelInput)0;
		CreateVertex( newPoint8, input[0], bladeLocalStartPos, steUpVecX3 + bladeOff + windAmt3X, float2( ( textureStart + textureEnd ) * 0.5f, textureBorderSize ), clipParam );
		OutputStream.Append( newPoint8 );
	}
/*
	pixelInput newPoint8 = (pixelInput)0;
	CreateVertex( newPoint8, input[0], bladeLocalStartPos, steUpVecX3 + bladeOff * 0.5f + windAmt3X, float2( ( textureStart + textureEnd ) * 0.5f, textureBorderSize ), clipParam );
	OutputStream.Append( newPoint8 );
	*/
	OutputStream.RestartStrip();

 }

 [maxvertexcount(32)]
 void geometryShader( point geometryShaderInput input[1], inout TriangleStream<pixelInput> OutputStream ) {

	float scale = 1.0f - saturate( ( length( cameraPos.xyz - input[0].position.xyz ) - GrassData2.x ) * GrassData2.y );
	if ( scale == 0.0f ) {
		return;
	}

	const int numSides = 2;
	float dist = GrassData1.z / 2.0f;
	int grassIdx = 0;

	for ( int y = 0; y < 2; y++ ) {
		for ( int x = 0; x < 2; x++, grassIdx++ ) {

			CreateGrassBlade( float3( x * dist, 0, y * dist ), input, OutputStream, scale, grassIdx );
		}
	}
 }

/**
 *	pixelShader
 */ 


Texture2D Mat4Diffuse	: register(t7);

 PS_OUTPUT pixelShader( pixelInput input, bool isFrontFace : SV_IsFrontFace )  {
 	PS_OUTPUT output = (PS_OUTPUT) 0;

	float fakeAO = abs( ( 1.0f - input.uv.y ) * ( 1.0f - fakeAOData.x ) + fakeAOData.x );
	fakeAO = pow( fakeAO, abs(fakeAOData.y) );

	if ( input.uv.x >= 2.0f/8.0f ) fakeAO = 1;
	output.Color.xyzw = grassDiffuseMap.Sample( SampleType, input.uv ).xyzw * fakeAO;
	clip( ( input.clipParam + output.Color.w ) - 0.01f );

	output.Normal.xyz = float3( 0.0f, 1.0f,0.0 );

	//dsfdsf
	output.Spec = float4( 0.25f, 0.25f, 0.25f, 1.0f );
	output.Depth.r = input.position2.x / input.position2.y;

	return output;
}
