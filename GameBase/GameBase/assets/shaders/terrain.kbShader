//==============================================================================
// terrain.kbShader
//
// 2017 kbEngine 2.0
//==============================================================================
cbuffer matrixBuffer {
	matrix modelMatrix;
	matrix modelViewMatrix;
	matrix viewMatrix;
	matrix mvpMatrix;
	matrix projection;
	matrix inverseProjection;
	matrix viewProjection;
	float4 cameraPos;
	float4 extraParams1;    // xyz - position, w - Time
	float4 extraParams2;    // x - amplitude, y - radius, z - time scale
	float4 extraParams3;
	float4 extraParams4;
};

//-------------------------------------
struct vertexInput {
	float4 position		   : POSITION;
	float2 uv			      : TEXCOORD0;
	float4 color		      : COLOR;
	float4 normal		      : NORMAL;
	float4 tangent		      : TANGENT;
};

//-------------------------------------
struct pixelInput {
	float4	position	      : SV_POSITION;
	float4	color		      : COLOR;
	float2	position2	   : TEXCOORD1;
	float3	normal		   : TEXCOORD2;
};

//-------------------------------------
struct PS_OUTPUT {
	float4 Color		      : SV_TARGET0;
	float4 Normal		      : SV_TARGET1;
	float2 Depth		      : SV_TARGET2;
};

/*
 *	vertexShader
 */
pixelInput vertexShader( vertexInput input ) {
	pixelInput output = (pixelInput)0;

   const float time = extraParams1.w;
   const float amp = extraParams2.x;
   const float radius = extraParams2.y;
   const float timescale = extraParams2.z;

   float4 inputPos = input.position;
   float3 pos2D = float3( input.position.x, 0.0f, input.position.z );
   float distToVert = length( pos2D - extraParams1.xyz );
   float attenuation = 1.0f - clamp( distToVert / radius, 0.f, 1.0f );
   float yOffset = amp * attenuation * sin( distToVert * 0.023f + time * timescale );

   inputPos.y += yOffset;

	output.position = mul( inputPos, mvpMatrix );

	output.color = input.color;
	output.position2 = output.position.zw;
	output.normal.xyz = mul( ( input.normal.xyz * 2.0f ) - 1.0f, modelMatrix );

	return output;
}

/*
 *	pixelShader
 */
 PS_OUTPUT pixelShader( pixelInput	input ) : SV_TARGET {
	PS_OUTPUT output = (PS_OUTPUT) 0;

	output.Color.xyz = input.color;
	output.Depth.r = input.position2.x / input.position2.y;

	output.Normal.xyz = normalize( input.normal );

	return output;
}