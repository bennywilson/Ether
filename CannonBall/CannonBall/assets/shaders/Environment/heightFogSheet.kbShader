//===================================================================================================
// depthFogSheet.kbShader
//
//
// 2020 kbEngine 2.0
//===================================================================================================
cbuffer matrixBuffer {
	matrix modelMatrix;
	matrix modelViewMatrix;
	matrix mvpMatrix;
	matrix inverseViewProjection;
	float4 cameraPosition;
	float4 time;

	float4 noise1Color;	// xyz - color, w - min step
	float4 noise2Color;  // xyz - color, w - min step
	float4 noiseScroll;
	float4 smoothStepsAndAlphaPower;

	float4 fadeParams;		// x - fade dist, y - rand seed
};

kbShaderState {
	srcBlend Blend_SrcAlpha
	dstBlend Blend_InvSrcAlpha
	blendOp BlendOp_Add

	cullMode CullMode_None
	colorWriteEnable ColorWriteEnable_rgb
}

//-------------------------------------
struct vertexInput {
	float4 position			: POSITION;
	float2 uv				: TEXCOORD0;
	float4 color			: COLOR;
	float4 normal			: NORMAL;
	float4 tangent			: TANGENT;
};

//-------------------------------------
struct pixelInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float4 color			: COLOR;
	float4 position2		: TEXCOORD1;
	float3 normal			: TEXCOORD2;
	float4 worldPos			: TEXCOORD3;
};


/**
 *	vertexShader
 */
pixelInput vertexShader( vertexInput input ) {
	pixelInput output = (pixelInput)(0);

	output.worldPos = mul( input.position, modelMatrix );
	output.position = mul( input.position, mvpMatrix );
	output.uv = input.uv;
	output.color = input.color;
	output.position2 = output.position;
	output.normal.xyz = mul( ( input.normal.xyz * 2.0f ) - 1.0f, (float3x3)modelMatrix );

	return output;
}

/**
 *	pixelShader
 */
SamplerState DefaultSamplerState;
Texture2D colorTexture(colorBuffer)				: register(t0);

SamplerState NormalSamplerState;
Texture2D normalTexture(normalBuffer)			: register(t1);

Texture2D specularTexture(specularBuffer)		: register(t2);

SamplerState DepthSamplerState;
Texture2D depthTexture(depthBuffer)				: register(t3);

Texture2D noiseTexture1 : register(t4);
Texture2D noiseTexture2 : register(t5);


float4 pixelShader( pixelInput input ) : SV_Target {

	float4 screenCoord = input.position2 / input.position2.w;
	float2 screenUV = screenCoord.xy * 0.5f + 0.5f;
	screenUV.y = 1.0f - screenUV.y;

	float4 worldPos = float4( screenCoord.xy, depthTexture.Sample( DepthSamplerState, screenUV ).r, 1 );
	worldPos = mul( worldPos, inverseViewProjection );
	worldPos /= worldPos.w;
	
	float fadeDist = 1;
	{//if ( length( cameraPosition.xyz - worldPos.xyz ) <= length( cameraPosition.xyz - input.worldPos.xyz ) + 1.0f ) {
		fadeDist = length( worldPos - input.worldPos );
		fadeDist = saturate( fadeDist / fadeParams.x );
	}
	clip( input.worldPos.y + 76.1751f );

	const float randTime = time.x + fadeParams.y;
	float3 noise1 = noiseTexture1.Sample( DefaultSamplerState, input.uv + float2( noiseScroll.x, noiseScroll.y ) * randTime.x ).xyz;
	noise1 = smoothstep( smoothStepsAndAlphaPower.x, 1.0f, noise1.x ) * noise1Color.xyz * noise1Color.w;

	float3 noise2 = noiseTexture1.Sample( DefaultSamplerState, input.uv.yx + float2( noiseScroll.z, noiseScroll.w ) * randTime.x ).xyz;
	noise2 = smoothstep( smoothStepsAndAlphaPower.y, 1.0f, noise2.x ) * noise2Color.xyz * noise2Color.w;

	float3 finalNoise = (noise1 + noise2);

	float uvFade = length( input.uv - float2( 0.5f, 0.5f ) ) / 0.5f;
	uvFade = smoothstep( 0.00f, 0.5f, 1.0f - uvFade );

	const float3 outColor = finalNoise.xyz * fadeDist * uvFade;
	const float luminance = pow( abs( dot( outColor, float3( 0.3f, 0.69f, 0.11f ) ) ), abs( smoothStepsAndAlphaPower.z ) );
	return float4(outColor, luminance);
}
