/// test_particle.kbshader
///
/// 2025 blk 1.0
struct SceneData {
	matrix modelMatrix;
	matrix world_matrix;
	matrix view_projection;
	float4 color;
	float4 spec;
	float4 camera;
	float4 pad0;
	matrix bones[128];
};

ConstantBuffer<SceneData> scene_constants[1024] : register(b0);

struct SceneIndex {
	uint index;
};
ConstantBuffer<SceneIndex> scene_index : register(b0, space1);

SamplerState SampleType : register(s0);
Texture2D color_tex : register(t0);

struct VertexInput {
	float4 position			: POSITION;
	float2 uv				: TEXCOORD0;
	float4 color			: COLOR;
	float rotation			: NORMAL;
	float pad					: TANGENT;
};

/*  struct ParticleVertex {
	Vec3 position;
	Vec2 uv;
	byte color[4];
	f32 rotation;
	byte tangent[4];
};*/

/// PixelInput
struct PixelInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float3 to_cam			: TEXCOORD1;
	float4 color			: COLOR;
};

///	vertex_shader
PixelInput vertex_shader(VertexInput local_vert) {
	SceneData scene_constant = scene_constants[scene_index.index];

	const float4 local_pos = local_vert.position;
	const float3 world_pos = local_pos.xyz;//mul(local_vert.position, scene_constant.world_matrix).xyz;

	float4 from_center = normalize(float4(local_vert.uv.xy - float2(0.5f, 0.5f), 0.0, 0.0)) * 1.f;

	PixelInput output = (PixelInput)(0);
	output.position = mul(local_pos + from_center, scene_constant.view_projection);
	output.to_cam = scene_constant.camera.xyz - world_pos;
	output.color = local_vert.color;
	output.uv = local_vert.uv;
	return output;
}

///	pixelShader
float4 pixel_shader(PixelInput input) : SV_TARGET {
	const float4 albedo = color_tex.Sample(SampleType, input.uv) * input.color;
	return albedo;
}