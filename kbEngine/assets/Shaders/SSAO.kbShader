//===================================================================================================
// SSAO.kbShader
//
//
// 2019 kbEngine 2.0
//===================================================================================================
cbuffer matrixBuffer {
   matrix				mvpMatrix;
	matrix	viewMatrix;
   matrix               inverseViewProjection;
   float4				offsetsAndWeights[16];
   int					numSamples;
};

kbShaderState {
	srcBlend Blend_DstColor
	dstBlend Blend_Zero
	colorwriteenable colorwriteenable_rgb
}

//-------------------------------------
struct vertexInput {
	float4 position			: POSITION;
	float2 uv				: TEXCOORD0;
};

//-------------------------------------
struct pixelInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float4 position2		: TEXCOORD1;
};

/**
 *	vertexShader
 */
pixelInput vertexShader( vertexInput input ) {
	pixelInput output = (pixelInput)(0);

	output.position = input.position;
	output.uv = input.uv;
	output.position2 = input.position;

	return output;
}

/**
 *	SSAOPixelMain
 */
SamplerState DiffuseSamplerState;
Texture2D colorTexture(colorBuffer)				: register(t0);

SamplerState NormalSamplerState;
Texture2D normalTexture(normalBuffer)			: register(t1);

Texture2D specularTexture(specularBuffer)		: register(t2);

SamplerState DepthSamplerState;
Texture2D depthTexture(depthBuffer)				: register(t3);

SamplerState ShadowMapSamplerState;
Texture2D ShadowMap(shadowBuffer)				: register(t4);

float CalculateOcclusion( float2 ab, float2 uv, float3 basePixelWorldPos, float3 basePixelWorldNormal ) {

	float maxOcclusionAngleDot = 0.3f;
	float g_intensity = 0.5f;
	float g_scale = 0.f;

	float4 testPos = float4( ab, depthTexture.Sample( DepthSamplerState, uv ).r, 1 );
	testPos = mul( testPos, inverseViewProjection );
	testPos /= testPos.w;
	
	float3 diff = testPos.xyz - basePixelWorldPos;

	if ( dot(diff, diff ) < 0.001f )
		{
return 0;
}
	float3 v = normalize( diff );
	float d = length( diff ) * g_scale;


	return saturate( dot( normalize( basePixelWorldNormal ), v) - maxOcclusionAngleDot  );

//max( 0.0f, dot( normalize( basePixelWorldNormal ), v ) - maxOcclusionAngleDot ) * ( 1.0f / ( 1.0f + d ) ) * g_intensity;


}


float4 pixelShader( pixelInput input ) : SV_TARGET {

	float4 diffuseColor = colorTexture.Sample( DiffuseSamplerState, input.uv );
	float3 normal = normalTexture.Sample( NormalSamplerState, input.uv ).xyz;
	float4 specColor = specularTexture.Sample( DiffuseSamplerState, input.uv );

	float4 worldPos = float4( input.position2.xy, depthTexture.Sample( DepthSamplerState, input.uv ).r, 1 );
	worldPos = mul( worldPos, inverseViewProjection );
	worldPos /= worldPos.w;

	int iterations = 4;
	float ao = 0;
	float2 pixelSize = 5 * float2( 1.0f / 1920.0f, 1.0f / 1080.0f );

	//for ( int j = 0; j < iterations; j++ ) {
	
		ao += CalculateOcclusion( input.position2.xy + 2 * float2(pixelSize.x, pixelSize.y), input.uv + float2(pixelSize.x, pixelSize.y), worldPos.xyz, normal );
		ao += CalculateOcclusion( input.position2.xy + 2 * float2(-pixelSize.x, pixelSize.y), input.uv + float2(-pixelSize.x, pixelSize.y), worldPos.xyz, normal );
		ao += CalculateOcclusion( input.position2.xy + 2 * float2(-pixelSize.x, -pixelSize.y), input.uv + float2(-pixelSize.x, -pixelSize.y), worldPos.xyz, normal );
		ao += CalculateOcclusion( input.position2.xy + 2 * float2(pixelSize.x, -pixelSize.y), input.uv + float2(pixelSize.x, -pixelSize.y), worldPos.xyz, normal );
//	}

	if ( ao > 0.25)
			return 0;
	return 1;
//	float finalAO = pow(abs( 1.0f - ao ), 1);
	//return float4( abs( finalAO.xxx ), 0 );//colorTexture.Sample( DiffuseSamplerState,  theUV );
}
