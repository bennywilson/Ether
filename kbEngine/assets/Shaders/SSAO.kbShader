//===================================================================================================
// SSAO.kbShader
//
//
// 2019 kbEngine 2.0
//===================================================================================================
cbuffer matrixBuffer {
   matrix				mvpMatrix;
   matrix               inverseViewProjection;
   float4				offsetsAndWeights[16];
   int					numSamples;
};

//-------------------------------------
struct vertexInput {
	float4 position			: POSITION;
	float2 uv				: TEXCOORD0;
};

//-------------------------------------
struct pixelInput {
	float4 position			: SV_POSITION;
	float2 uv				: TEXCOORD0;
	float4 position2		: TEXCOORD1;
};

/**
 *	SSAOVertexMain
 */
pixelInput SSAOVertexMain( vertexInput input ) {
	pixelInput output = (pixelInput)(0);

	output.position = input.position;
	output.uv = input.uv;
	output.position2 = input.position;

	return output;
}

/**
 *	SSAOPixelMain
 */
SamplerState DiffuseSamplerState;
Texture2D colorTexture(colorBuffer)				: register(t0);

SamplerState NormalSamplerState;
Texture2D normalTexture(normalBuffer)			: register(t1);

Texture2D specularTexture(specularBuffer)		: register(t2);

SamplerState DepthSamplerState;
Texture2D depthTexture(depthBuffer)				: register(t3);

SamplerState ShadowMapSamplerState;
Texture2D ShadowMap(shadowBuffer)				: register(t4);

float CalculateOcclusion( float2 ab, float2 uv, float3 baseWorldPos ) {
	float4 worldPos = float4( ab, depthTexture.Sample( DepthSamplerState, uv ).r, 1 );
	worldPos = mul( worldPos, inverseViewProjection );
	worldPos /= worldPos.w;
	
	if ( worldPos.z < baseWorldPos.z - 2.75f) {
		return 1.0f;
	}

	return 0.0f;
}

float4 SSAOPixelMain( pixelInput input ) : SV_TARGET {

	float4 diffuseColor = colorTexture.Sample( DiffuseSamplerState, input.uv );
	float3 normal = normalTexture.Sample( NormalSamplerState, input.uv ).xyz;
	float4 specColor = specularTexture.Sample( DiffuseSamplerState, input.uv );

	float4 worldPos = float4( input.position2.xy, depthTexture.Sample( DepthSamplerState, input.uv ).r, 1 );
	worldPos = mul( worldPos, inverseViewProjection );
	worldPos /= worldPos.w;

	int iterations = 4;
	float ao = 0;
	float2 pixelSize = float2( 1.0f / 1920.0f, 1.0f / 1080.0f );
	for ( int j = 0; j < iterations; j++ ) {
	
		ao += CalculateOcclusion( input.position2.xy - pixelSize * 2.0f, input.uv - pixelSize, worldPos.xyz );
		ao += CalculateOcclusion( input.position2.xy + pixelSize * 2.0f, input.uv + pixelSize, worldPos.xyz );
	//	ao += CalculateOcclusion( i.uv - pixelSize, worldPos.xyz );
		// ao += CalculateOcclusion( i.uv - pixelSize, worldPos.xyz );
	}

	return ao;
}
